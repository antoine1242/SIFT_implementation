
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>TP</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-18"><meta name="DC.source" content="TP.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Exercice 1: Signaux simples</a></li><li><a href="#2">1.1.</a></li><li><a href="#3">1.2.</a></li><li><a href="#4">1.3.</a></li><li><a href="#5">1.4.</a></li><li><a href="#6">Exercice 2: &Eacute;chantillonnage</a></li><li><a href="#7">2.1.</a></li><li><a href="#8">2.2.</a></li><li><a href="#9">2.3.</a></li><li><a href="#10">2.4.</a></li><li><a href="#11">Exercice 3: Analyse spectrale</a></li><li><a href="#12">3.1.</a></li><li><a href="#13">3.2.</a></li><li><a href="#14">3.3.</a></li><li><a href="#15">3.4.</a></li><li><a href="#16">3.4.1.</a></li><li><a href="#17">3.4.2.</a></li><li><a href="#18">3.4.3.</a></li><li><a href="#19">3.5.</a></li><li><a href="#20">Exercice 4: Filtrage audio</a></li><li><a href="#21">4.1.</a></li><li><a href="#22">4.2.</a></li><li><a href="#23">4.3.</a></li><li><a href="#24">4.4.</a></li><li><a href="#25">4.5.</a></li><li><a href="#26">4.6.</a></li><li><a href="#27">4.7.</a></li><li><a href="#28">4.8.</a></li><li><a href="#29">4.8.1.</a></li><li><a href="#30">4.8.2.</a></li><li><a href="#31">4.8.3.</a></li></ul></div><h2 id="1">Exercice 1: Signaux simples</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;
</pre><h2 id="2">1.1.</h2><pre class="codeinput">s = @(t) sin(pi*t) ./ (pi*t);

t = linspace(-4, 4, 1000);

plot(t, s(t));
title(<span class="string">'Sinus cardinal en fonction de t'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'s(t)'</span>);
legend(<span class="string">'s (Sinus cardinal)'</span>);

<span class="comment">% R&eacute;ponse question: Le signal s est connu sous le nom de sinus cardinal.</span>
</pre><img vspace="5" hspace="5" src="TP_01.png" alt=""> <h2 id="3">1.2.</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;

s1 = @(t) sin(t);
s2 = @(t) sin(3*t) / 3;
s3 = @(t) sin(5*t) / 5;

t = linspace(-2, 2, 500);

hold <span class="string">on</span>;
plot(t, s1(t))
plot(t, s2(t))
plot(t, s3(t))

title(<span class="string">'Superposition des signaux s1 s2 et s3 en fonction de t'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'Signaux s1(t) s2(t) et s3(t)'</span>);
legend(<span class="string">'s1'</span>, <span class="string">'s2'</span>, <span class="string">'s3'</span>);
</pre><img vspace="5" hspace="5" src="TP_02.png" alt=""> <h2 id="4">1.3.</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;

s1 = @(t) sin(t);
s2 = @(t) sin(3*t) / 3;
s3 = @(t) sin(5*t) / 5;
somme = @(t) s1(t) + s2(t) + s3(t);

t = linspace(-2, 2, 500);

hold <span class="string">on</span>;
plot(t, s1(t), <span class="string">'--'</span>)
plot(t, s2(t), <span class="string">'--'</span>)
plot(t, s3(t), <span class="string">'--'</span>)
plot(t, somme(t), <span class="string">'LineWidth'</span>, 2)

title(<span class="string">'Superposition des signaux s1 s2 s3 et leur somme en fonction de t'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'Signaux s1 s2 s3 et leur somme'</span>);
legend(<span class="string">'s1'</span>, <span class="string">'s2'</span>, <span class="string">'s3'</span>, <span class="string">'somme'</span>);
</pre><img vspace="5" hspace="5" src="TP_03.png" alt=""> <h2 id="5">1.4.</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;

<span class="comment">% Calcul de la fonction S50(t)</span>
t = linspace(-2, 2, 500);
S50 = zeros(1, length(t));
<span class="keyword">for</span> i=0:500
   k = 2*i + 1;
   h = sin(k*t) / k;
   S50 = (S50 + h);
<span class="keyword">end</span>
S50 = 0.5 + (2/pi)* S50;

figure(<span class="string">'Name'</span>, <span class="string">'Approximation de la fonction &eacute;chelon'</span>);
plot(t, S50);
title(<span class="string">'Approximation de la fonction &eacute;chelon'</span>);
xlabel(<span class="string">'t (s)'</span>);
ylabel(<span class="string">'S50(t)'</span>);

<span class="comment">% R&eacute;ponse question: Le signal S50(t) semble approximer la fonction &eacute;chelon.</span>
</pre><img vspace="5" hspace="5" src="TP_04.png" alt=""> <h2 id="6">Exercice 2: &Eacute;chantillonnage</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;
</pre><h2 id="7">2.1.</h2><p>Le signal Y(t) peut &ecirc;tre d&eacute;compos&eacute; en trois signaux:</p><pre class="codeinput">Y_1 = @(t) 2*sin(165*pi*t);
Y_2 = @(t) 13*cos(6*pi*t);
Y_3 = @(t) -3*cos(80*pi*t);

<span class="comment">% &Agrave; l'aide de s(t) = A * sin(w*t + phi) et f = w / 2pi on peut trouver</span>
<span class="comment">% trois fr&eacute;quences dans le signal Y(t):</span>

<span class="comment">% Y_1 -&gt; 165pi / 2pi = 82.5 Hz</span>
<span class="comment">% Y_2 -&gt; 6pi / 2pi = 3 Hz</span>
<span class="comment">% Y_3 -&gt; 80pi / 2pi = 40 Hz</span>
</pre><h2 id="8">2.2.</h2><pre class="codeinput">Y = @(t) Y_1(t) + Y_2(t) + Y_3(t);

figure(<span class="string">'pos'</span>, [10,10,600,900]);

type <span class="string">subplot_frequence_echantillonnage.m</span>;

subplot_frequence_echantillonnage(1, 20, Y);
subplot_frequence_echantillonnage(2, 75, Y);
subplot_frequence_echantillonnage(3, 100, Y);
subplot_frequence_echantillonnage(4, 160, Y);
subplot_frequence_echantillonnage(5, 180, Y);
subplot_frequence_echantillonnage(6, 330, Y);
</pre><pre class="codeoutput">
function [] = subplot_frequence_echantillonnage(position, frequence, Y)
% Cette fonction ajoute un subplot &agrave; la figure regroupant les six 
% repr&eacute;sentations de Y(t) avec diff&eacute;rentes fr&eacute;quences d'&eacute;chantillonage  
    subplot(6,1,position);
    t = linspace(0, 1, frequence);
    plot(t, Y(t));
    ylim([-20, 20]);
    title(strcat({'Y en fonction de t pour une fr&eacute;quence d''&eacute;chantillonnage de '}, int2str(frequence), {' Hz'}));
    xlabel('t');
    ylabel('Y(t)');
end

</pre><img vspace="5" hspace="5" src="TP_05.png" alt=""> <h2 id="9">2.3.</h2><pre class="codeinput"><span class="comment">% Plus la fr&eacute;quence d'&eacute;chantillonnage est &eacute;lev&eacute;e, plus l'&eacute;chantillon &eacute;pouse</span>
<span class="comment">% le r&eacute;el signal.</span>
</pre><h2 id="10">2.4.</h2><pre class="codeinput"><span class="comment">% Le th&eacute;or&egrave;me de Nyquist-Shannon stipule que la fr&eacute;quence d'&eacute;chantillonnage</span>
<span class="comment">% doit &ecirc;tre au moins &eacute;gale au double de la fr&eacute;quence maximale du signal</span>
<span class="comment">% analogique.</span>
<span class="comment">% Ici la fr&eacute;quence maximale du signal Y(t) est:</span>
<span class="comment">% f_max = max(82.5, 3, 40) = 82.5 Hz</span>
<span class="comment">% R&eacute;ponse question: Donc les fr&eacute;quences 180 Hz et 330 Hz respectent la condition &gt;= 2*82.5</span>
<span class="comment">% Hz.</span>

<span class="comment">% R&eacute;ponse question: Un compromis doit &ecirc;tre fait entre la pr&eacute;cision du signal</span>
<span class="comment">% reconstitu&eacute; et la quantit&eacute; de donn&eacute;es recueillies.</span>
<span class="comment">% En effet, si la fr&eacute;quence d'&eacute;chantillonage est &eacute;lev&eacute;e il sera</span>
<span class="comment">% possible d'&eacute;chantilloner des fr&eacute;quences &eacute;lev&eacute;es. De plus, la latence du</span>
<span class="comment">% signal sera diminu&eacute;e. Cependant, si la fr&eacute;quence d'&eacute;chantillonage est</span>
<span class="comment">% &eacute;lev&eacute;e une plus grande quantit&eacute; de donn&eacute;es devra &ecirc;tre recueillie afin</span>
<span class="comment">% de repr&eacute;senter ce signal.</span>
</pre><h2 id="11">Exercice 3: Analyse spectrale</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;
</pre><h2 id="12">3.1.</h2><pre class="codeinput">Fe = 250;
Y_1 = @(t) 7*sin(2*pi*10*t);
Y_2 = @(t) 4*sin(2*pi*25*t + pi/3);
Y_3 = @(t) 3*cos(2*pi*50*t);

t = linspace(0, 1, Fe);
hold <span class="string">on</span>;
plot(t, Y_1(t));
plot(t, Y_2(t));
plot(t, Y_3(t));
title(<span class="string">'Signaux Y_1, Y_2, et Y_3 en fonction de t'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'Signaux Y_1, Y_2, et Y_3'</span>);
legend(<span class="string">'Y_1'</span>, <span class="string">'Y_2'</span>, <span class="string">'Y_3'</span>);
</pre><img vspace="5" hspace="5" src="TP_06.png" alt=""> <h2 id="13">3.2.</h2><pre class="codeinput"><span class="comment">% R&eacute;ponse question:</span>

<span class="comment">% P&eacute;riode d&eacute;termin&eacute;e graphiquement:</span>
<span class="comment">% T_1_graph = 0,17671 - 0,076305 = 0,100405</span>
<span class="comment">% T_2_graph = 0,10442 - 0,064257 = 0,040163</span>
<span class="comment">% T_3_graph = 0,068273 - 0,048193 = 0,02008</span>

<span class="comment">% P&eacute;riode d&eacute;termin&eacute;e th&eacute;oriquement:</span>
<span class="comment">% &Agrave; l'aide de f = w/2pi  et T = 1/f nous obtenons T = 2pi / w</span>
<span class="comment">% T_1_th&eacute;o = 2pi / (2pi*10) = 0,1</span>
<span class="comment">% T_2_th&eacute;o = 2pi / (2pi*25) = 0,04</span>
<span class="comment">% T_3_th&eacute;o = 2pi / (2pi*50) = 0,02</span>

<span class="comment">% Comparaison P&eacute;riode d&eacute;termin&eacute;e graphiquement vs P&eacute;riode d&eacute;termin&eacute;e</span>
<span class="comment">% th&eacute;oriquement:</span>
<span class="comment">% T_1_th&eacute;o_vs_graph = |0,1 - 0,100405| / 0,1 = 0.405% erreur</span>
<span class="comment">% T_2_th&eacute;o_vs_graph = |0,04 - 0,040163| / 0,04 = 0.4075% erreur</span>
<span class="comment">% T_3_th&eacute;o_vs_graph = |0,02 - 0,02008| / 0,02 = 0.4% erreur</span>
</pre><h2 id="14">3.3.</h2><pre class="codeinput">clf;

Z = @(t) Y_1(t) + Y_2(t) + Y_3(t);
plot(t, Z(t));
title(<span class="string">'Somme des signaux Y1, Y2 et Y3 en fonction de t'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'Somme des signaux Y1, Y2 et Y3'</span>);
legend(<span class="string">'Z'</span>);

<span class="comment">% R&eacute;ponse question:</span>
<span class="comment">% &Agrave; l'aide de f = 1 / T o&ugrave; T est :</span>
<span class="comment">% T = 0,026908 - 0,068273 = 0,200807</span>
<span class="comment">% La fr&eacute;quence de Z(t) semble &ecirc;tre de 1 / 0,200807 = 4,98 Hz</span>
</pre><img vspace="5" hspace="5" src="TP_07.png" alt=""> <h2 id="15">3.4.</h2><pre class="codeinput"><span class="comment">% R&eacute;ponse question:</span>
<span class="comment">% Le spectre de fr&eacute;quence de chacun des signaux pr&eacute;sente l'intensit&eacute; du</span>
<span class="comment">% signal en fonction de la fr&eacute;quence. Il nous est possible de constater que</span>
<span class="comment">% chaque spectre de fr&eacute;quence a une fr&eacute;quence pro&eacute;minente. Cette fr&eacute;quence</span>
<span class="comment">% pro&eacute;minente correspond bel et bien &agrave; la fr&eacute;quence th&eacute;orique de chacun des</span>
<span class="comment">% signaux. De plus, l'intensit&eacute; du signal repr&eacute;sent&eacute; dans chacun des</span>
<span class="comment">% spectres de fr&eacute;quence correspond aussi &agrave; l'intensit&eacute; th&eacute;orique de chacun</span>
<span class="comment">% des signaux.</span>
</pre><h2 id="16">3.4.1.</h2><pre class="codeinput">clf;
Y_1_fft = fft(Y_1(t));
bar(0:249, 2*abs(Y_1_fft)/length(Y_1_fft));
xlim([0 124])
title(<span class="string">'Spectre de fr&eacute;quence de Y1'</span>);
ylabel(<span class="string">'Intensit&eacute;'</span>);
xlabel(<span class="string">'Fr&eacute;quence'</span>);
</pre><img vspace="5" hspace="5" src="TP_08.png" alt=""> <h2 id="17">3.4.2.</h2><pre class="codeinput">clf;
Y_2_fft = fft(Y_2(t));
bar(0:249, 2*abs(Y_2_fft)/length(Y_2_fft));
xlim([0 124])
title(<span class="string">'Spectre de fr&eacute;quence de Y2'</span>);
ylabel(<span class="string">'Intensit&eacute;'</span>);
xlabel(<span class="string">'Fr&eacute;quence'</span>);
</pre><img vspace="5" hspace="5" src="TP_09.png" alt=""> <h2 id="18">3.4.3.</h2><pre class="codeinput">clf;
Y_3_fft = fft(Y_3(t));
bar(0:249, 2*abs(Y_3_fft)/length(Y_3_fft));
xlim([0 124])
title(<span class="string">'Spectre de fr&eacute;quence de Y3'</span>);
ylabel(<span class="string">'Intensit&eacute;'</span>);
xlabel(<span class="string">'Fr&eacute;quence'</span>);
</pre><img vspace="5" hspace="5" src="TP_10.png" alt=""> <h2 id="19">3.5.</h2><pre class="codeinput">clf;
audio_fft = fft(Z(t));
bar(0:249, 2*abs(audio_fft)/length(audio_fft));
xlim([0 124])
title(<span class="string">'Spectre de fr&eacute;quence de Z'</span>);
ylabel(<span class="string">'Intensit&eacute;'</span>);
xlabel(<span class="string">'Fr&eacute;quence (Hz)'</span>);

<span class="comment">% R&eacute;ponse question:</span>
<span class="comment">% Ce spectre de fr&eacute;quence pr&eacute;sente l'intensit&eacute; du  signal en fonction de la</span>
<span class="comment">% fr&eacute;quence. Il nous est possible de constater qu'il y a trois fr&eacute;quences</span>
<span class="comment">% pro&eacute;minentes. Ces fr&eacute;quences ainsi que leur intensit&eacute; correspondent aux</span>
<span class="comment">% signaux Y_1(t), Y_2(t), et Y_3(t) qui composent le signal Z(t) analys&eacute;.</span>
</pre><img vspace="5" hspace="5" src="TP_11.png" alt=""> <h2 id="20">Exercice 4: Filtrage audio</h2><pre class="codeinput">close <span class="string">all</span>;
clear <span class="string">all</span>;
clc;
</pre><h2 id="21">4.1.</h2><pre class="codeinput">[Data,Fe] = audioread(<span class="string">'audio.wav'</span>);

player = audioplayer(Data, Fe);
<span class="comment">% play(player);</span>

<span class="comment">% Perturbation #1: Son constant &agrave; haute fr&eacute;quence (son aigu)</span>
<span class="comment">% Perturbation #2: Son constant &agrave; base fr&eacute;quence (son grave)</span>
</pre><h2 id="22">4.2.</h2><p>Calcul taille des donn&eacute;es audio recueillies</p><pre class="codeinput">L = length(Data);
<span class="comment">% Obtenir vecteur repr&eacute;sentant la plage de fr&eacute;quences du fichier audio</span>
f = Fe*(0:(L/2))/L;
<span class="comment">% Obtenir fft du signal audio</span>
audio_fft = fft(Data);
<span class="comment">% Seulement prendre les valeur positives + normaliser les donn&eacute;es</span>
all_data = abs(audio_fft/L);
<span class="comment">% S&eacute;lectionner seulement la moiti&eacute; des</span>
firt_half = all_data(1:L/2+1);
<span class="comment">% Doubler amplitude des signaux de la premi&egrave;re moiti&eacute; puisque les signaux</span>
<span class="comment">% de la seconde moiti&eacute; ont &eacute;t&eacute; group&eacute; au signaux de la premi&egrave;re partie.</span>
firt_half(2:end-1) = 2*firt_half(2:end-1);

plot(f,firt_half)
title(<span class="string">'TDF du signal audio.wav'</span>)
xlabel(<span class="string">'Fr&eacute;quence'</span>)
ylabel(<span class="string">'Intensit&eacute; (Hz)'</span>)
</pre><img vspace="5" hspace="5" src="TP_12.png" alt=""> <h2 id="23">4.3.</h2><pre class="codeinput"><span class="comment">% R&eacute;ponse question: En observant une fr&eacute;quence de 1244.69 Hz il nous est</span>
<span class="comment">% possible d'affirmer que cette fr&eacute;quence correspond &agrave; un r&eacute;# ou mib.</span>
</pre><h2 id="24">4.4.</h2><pre class="codeinput"><span class="comment">% Cr&eacute;ation du filtre et application de celui-ci sur le fichier audio</span>
lpf = fir1(128, 1240 / Fe, <span class="string">"low"</span>);
lpf_data = filter(lpf, 1, Data);

<span class="comment">% Affichage du nouveau signal sonore (non demand&eacute;)</span>
filtered_data_fft = fft(lpf_data);
all_data = abs(filtered_data_fft/L);
firt_half = all_data(1:L/2+1);
firt_half(2:end-1) = 2*firt_half(2:end-1);

plot(f,firt_half)
title(<span class="string">'TDF du signal audio.wav avec lowpass filter'</span>)
xlabel(<span class="string">'Fr&eacute;quence'</span>)
ylabel(<span class="string">'Intensit&eacute; (Hz)'</span>)

audiowrite(<span class="string">'new_audio_with_low_pass.wav'</span>, lpf_data, Fe);

<span class="comment">% R&eacute;ponse question: Nous perdons toutes les fr&eacute;quences sup&eacute;rieure &agrave; 1240</span>
<span class="comment">% Hz et donc certaines notes de la musique.</span>
<span class="comment">% Nous pourrions cr&eacute;er un filtre pour seulement un petit ensemble de</span>
<span class="comment">% fr&eacute;quence ce qui limiterait les pertes.</span>
</pre><img vspace="5" hspace="5" src="TP_13.png" alt=""> <h2 id="25">4.5.</h2><pre class="codeinput">highPassFilter_Chebyshev = fir1(128,250/Fe,<span class="string">'high'</span>,chebwin(128+1, 30));
highPassFilter_Hamming = fir1(128,250/Fe,<span class="string">'high'</span>, hamming(128+1));
highPassFilter_Blackman = fir1(128,250/Fe,<span class="string">'high'</span>,blackman(128+1));
</pre><h2 id="26">4.6.</h2><pre class="codeinput">HD1 = dfilt.dffir(highPassFilter_Chebyshev);
HD2 = dfilt.dffir(highPassFilter_Hamming);
HD3 = dfilt.dffir(highPassFilter_Blackman);
[H, w] = freqz([HD1, HD2, HD3]);
figure(2)
subplot(2,1,1);
plot(w/pi,20*log10(abs(H)));
legend(<span class="string">'Chebyshev'</span>, <span class="string">'Hamming'</span>, <span class="string">'Blackman'</span>);
title(<span class="string">'R&eacute;ponse fr&eacute;quentielle'</span>)
xlabel(<span class="string">'Normalized Frequency (x pi rad/sample)'</span>)
ylabel(<span class="string">'Magnitude (dB)'</span>)
grid <span class="string">on</span>
subplot(2,1,2);
plot(w, angle(H));
title(<span class="string">'Phase'</span>)
xlabel(<span class="string">'Normalized Frequency (x pi rad/sample)'</span>)
ylabel(<span class="string">'Phase (radians)'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="TP_14.png" alt=""> <h2 id="27">4.7.</h2><pre class="codeinput">[Data,Fe] = audioread(<span class="string">'new_audio_with_low_pass.wav'</span>);
hpf_Chebyshev = filter(highPassFilter_Chebyshev, 1, Data);
hpf_Hamming = filter(highPassFilter_Hamming, 1, Data);
hpf_Blackman = filter(highPassFilter_Blackman, 1, Data);

audiowrite(<span class="string">'Chebyshev.wav'</span>, hpf_Chebyshev, Fe);
audiowrite(<span class="string">'Hamming.wav'</span>, hpf_Chebyshev, Fe);
audiowrite(<span class="string">'Blackman.wav'</span>, hpf_Chebyshev, Fe);

<span class="comment">% Nous remarquons que le son de la fr&eacute;quence basse s'est vu att&eacute;nu&eacute;.</span>
<span class="comment">% Nous perdons de l'intensit&eacute; pour toutes les fr&eacute;quences inf&eacute;rieures &agrave; la</span>
<span class="comment">% fr&eacute;quence de coupure et donc certaines notes de la musique. Le signal</span>
<span class="comment">% restaur&eacute; sera donc moins fort au niveau des fr&eacute;quences inf&eacute;rieures &agrave; la</span>
<span class="comment">% fr&eacute;quence de coupure, soit 250 Hz.</span>
</pre><h2 id="28">4.8.</h2><pre class="codeinput">type <span class="string">plotSpectreFrequence.m</span>;

<span class="comment">% Les spectres correspondent &agrave; ce que nous avons entendu. Effectivement, le</span>
<span class="comment">% son tr&egrave;s fort en basse fr&eacute;quence est encore audible, et on voit sur le</span>
<span class="comment">% spectre qu'il reste encore plus fort que le reste du signal. Par contre,</span>
<span class="comment">% son intensit&eacute; est plus faible que le signal original.</span>
</pre><pre class="codeoutput">
function [] = plotSpectreFrequence(nomFichier)

[Data,Fe] = audioread(nomFichier);

% Calcul taille des donn&eacute;es audio recueillies
L = length(Data);
% Obtenir vecteur repr&eacute;sentant la plage de fr&eacute;quences du fichier audio
f = Fe*(0:(L/2))/L;
% Obtenir fft du signal audio
audio_fft = fft(Data);
% Seulement prendre les valeur positives + normaliser les donn&eacute;es
all_data = abs(audio_fft/L);
% S&eacute;lectionner seulement la moiti&eacute; des 
firt_half = all_data(1:L/2+1);
% Doubler amplitude des signaux de la premi&egrave;re moiti&eacute; puisque les signaux
% de la seconde moiti&eacute; ont &eacute;t&eacute; group&eacute; au signaux de la premi&egrave;re partie.
firt_half(2:end-1) = 2*firt_half(2:end-1);

plot(f,firt_half) 
title(strcat({'TDF du signal '}, nomFichier));
xlabel('Fr&eacute;quence')
ylabel('Intensit&eacute;')
end

</pre><h2 id="29">4.8.1.</h2><pre class="codeinput">clf;
plotSpectreFrequence(<span class="string">'Chebyshev.wav'</span>);
</pre><img vspace="5" hspace="5" src="TP_15.png" alt=""> <h2 id="30">4.8.2.</h2><pre class="codeinput">clf;
plotSpectreFrequence(<span class="string">'Hamming.wav'</span>);
</pre><img vspace="5" hspace="5" src="TP_16.png" alt=""> <h2 id="31">4.8.3.</h2><pre class="codeinput">clf;
plotSpectreFrequence(<span class="string">'Blackman.wav'</span>);
</pre><img vspace="5" hspace="5" src="TP_17.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Exercice 1: Signaux simples
close all;
clear all;
clc;

%% 1.1.

s = @(t) sin(pi*t) ./ (pi*t);

t = linspace(-4, 4, 1000);

plot(t, s(t));
title('Sinus cardinal en fonction de t');
xlabel('t');
ylabel('s(t)');
legend('s (Sinus cardinal)');

% Réponse question: Le signal s est connu sous le nom de sinus cardinal.

%% 1.2. 
close all;
clear all;
clc;

s1 = @(t) sin(t);
s2 = @(t) sin(3*t) / 3;
s3 = @(t) sin(5*t) / 5;

t = linspace(-2, 2, 500);

hold on;
plot(t, s1(t))
plot(t, s2(t))
plot(t, s3(t))

title('Superposition des signaux s1 s2 et s3 en fonction de t');
xlabel('t');
ylabel('Signaux s1(t) s2(t) et s3(t)');
legend('s1', 's2', 's3');

%% 1.3. 
close all;
clear all;
clc;

s1 = @(t) sin(t);
s2 = @(t) sin(3*t) / 3;
s3 = @(t) sin(5*t) / 5;
somme = @(t) s1(t) + s2(t) + s3(t);

t = linspace(-2, 2, 500);

hold on;
plot(t, s1(t), 'REPLACE_WITH_DASH_DASH')
plot(t, s2(t), 'REPLACE_WITH_DASH_DASH')
plot(t, s3(t), 'REPLACE_WITH_DASH_DASH')
plot(t, somme(t), 'LineWidth', 2)

title('Superposition des signaux s1 s2 s3 et leur somme en fonction de t');
xlabel('t');
ylabel('Signaux s1 s2 s3 et leur somme');
legend('s1', 's2', 's3', 'somme');

%% 1.4.
close all;
clear all;
clc;

% Calcul de la fonction S50(t)
t = linspace(-2, 2, 500);
S50 = zeros(1, length(t));
for i=0:500
   k = 2*i + 1;
   h = sin(k*t) / k;
   S50 = (S50 + h);
end
S50 = 0.5 + (2/pi)* S50;

figure('Name', 'Approximation de la fonction échelon');
plot(t, S50);
title('Approximation de la fonction échelon');
xlabel('t (s)');
ylabel('S50(t)');

% Réponse question: Le signal S50(t) semble approximer la fonction échelon.

%% Exercice 2: Échantillonnage
close all;
clear all;
clc;

%% 2.1.
% Le signal Y(t) peut être décomposé en trois signaux: 
Y_1 = @(t) 2*sin(165*pi*t);
Y_2 = @(t) 13*cos(6*pi*t);
Y_3 = @(t) -3*cos(80*pi*t); 

% À l'aide de s(t) = A * sin(w*t + phi) et f = w / 2pi on peut trouver
% trois fréquences dans le signal Y(t):

% Y_1 -> 165pi / 2pi = 82.5 Hz
% Y_2 -> 6pi / 2pi = 3 Hz
% Y_3 -> 80pi / 2pi = 40 Hz

%% 2.2. 
Y = @(t) Y_1(t) + Y_2(t) + Y_3(t);

figure('pos', [10,10,600,900]);

type subplot_frequence_echantillonnage.m;

subplot_frequence_echantillonnage(1, 20, Y);
subplot_frequence_echantillonnage(2, 75, Y);
subplot_frequence_echantillonnage(3, 100, Y);
subplot_frequence_echantillonnage(4, 160, Y);
subplot_frequence_echantillonnage(5, 180, Y);
subplot_frequence_echantillonnage(6, 330, Y);

%% 2.3. 

% Plus la fréquence d'échantillonnage est élevée, plus l'échantillon épouse
% le réel signal.

%% 2.4. 

% Le théorème de Nyquist-Shannon stipule que la fréquence d'échantillonnage
% doit être au moins égale au double de la fréquence maximale du signal
% analogique.
% Ici la fréquence maximale du signal Y(t) est: 
% f_max = max(82.5, 3, 40) = 82.5 Hz
% Réponse question: Donc les fréquences 180 Hz et 330 Hz respectent la condition >= 2*82.5
% Hz.

% Réponse question: Un compromis doit être fait entre la précision du signal 
% reconstitué et la quantité de données recueillies.
% En effet, si la fréquence d'échantillonage est élevée il sera
% possible d'échantilloner des fréquences élevées. De plus, la latence du 
% signal sera diminuée. Cependant, si la fréquence d'échantillonage est
% élevée une plus grande quantité de données devra être recueillie afin 
% de représenter ce signal.

%% Exercice 3: Analyse spectrale
close all;
clear all;
clc;

%% 3.1. 
Fe = 250;
Y_1 = @(t) 7*sin(2*pi*10*t);
Y_2 = @(t) 4*sin(2*pi*25*t + pi/3);
Y_3 = @(t) 3*cos(2*pi*50*t);

t = linspace(0, 1, Fe);
hold on;
plot(t, Y_1(t));
plot(t, Y_2(t));
plot(t, Y_3(t));
title('Signaux Y_1, Y_2, et Y_3 en fonction de t');
xlabel('t');
ylabel('Signaux Y_1, Y_2, et Y_3');
legend('Y_1', 'Y_2', 'Y_3');

%% 3.2. 

% Réponse question: 

% Période déterminée graphiquement:
% T_1_graph = 0,17671 - 0,076305 = 0,100405
% T_2_graph = 0,10442 - 0,064257 = 0,040163
% T_3_graph = 0,068273 - 0,048193 = 0,02008

% Période déterminée théoriquement:
% À l'aide de f = w/2pi  et T = 1/f nous obtenons T = 2pi / w
% T_1_théo = 2pi / (2pi*10) = 0,1
% T_2_théo = 2pi / (2pi*25) = 0,04
% T_3_théo = 2pi / (2pi*50) = 0,02

% Comparaison Période déterminée graphiquement vs Période déterminée
% théoriquement:
% T_1_théo_vs_graph = |0,1 - 0,100405| / 0,1 = 0.405% erreur
% T_2_théo_vs_graph = |0,04 - 0,040163| / 0,04 = 0.4075% erreur
% T_3_théo_vs_graph = |0,02 - 0,02008| / 0,02 = 0.4% erreur

%% 3.3.
clf;

Z = @(t) Y_1(t) + Y_2(t) + Y_3(t);
plot(t, Z(t));
title('Somme des signaux Y1, Y2 et Y3 en fonction de t');
xlabel('t');
ylabel('Somme des signaux Y1, Y2 et Y3');
legend('Z');

% Réponse question:
% À l'aide de f = 1 / T où T est : 
% T = 0,026908 - 0,068273 = 0,200807
% La fréquence de Z(t) semble être de 1 / 0,200807 = 4,98 Hz

%% 3.4. 

% Réponse question:
% Le spectre de fréquence de chacun des signaux présente l'intensité du
% signal en fonction de la fréquence. Il nous est possible de constater que
% chaque spectre de fréquence a une fréquence proéminente. Cette fréquence
% proéminente correspond bel et bien à la fréquence théorique de chacun des
% signaux. De plus, l'intensité du signal représenté dans chacun des 
% spectres de fréquence correspond aussi à l'intensité théorique de chacun
% des signaux.

%% 3.4.1.

clf;
Y_1_fft = fft(Y_1(t));
bar(0:249, 2*abs(Y_1_fft)/length(Y_1_fft));
xlim([0 124])
title('Spectre de fréquence de Y1');
ylabel('Intensité');
xlabel('Fréquence');

%% 3.4.2.
clf;
Y_2_fft = fft(Y_2(t));
bar(0:249, 2*abs(Y_2_fft)/length(Y_2_fft));
xlim([0 124])
title('Spectre de fréquence de Y2');
ylabel('Intensité');
xlabel('Fréquence');

%% 3.4.3.
clf;
Y_3_fft = fft(Y_3(t));
bar(0:249, 2*abs(Y_3_fft)/length(Y_3_fft));
xlim([0 124])
title('Spectre de fréquence de Y3');
ylabel('Intensité');
xlabel('Fréquence');


%% 3.5. 
clf;
audio_fft = fft(Z(t));
bar(0:249, 2*abs(audio_fft)/length(audio_fft));
xlim([0 124])
title('Spectre de fréquence de Z');
ylabel('Intensité');
xlabel('Fréquence (Hz)');

% Réponse question:
% Ce spectre de fréquence présente l'intensité du  signal en fonction de la 
% fréquence. Il nous est possible de constater qu'il y a trois fréquences 
% proéminentes. Ces fréquences ainsi que leur intensité correspondent aux 
% signaux Y_1(t), Y_2(t), et Y_3(t) qui composent le signal Z(t) analysé.


%% Exercice 4: Filtrage audio
close all;
clear all;
clc;

%% 4.1.
[Data,Fe] = audioread('audio.wav');

player = audioplayer(Data, Fe);
% play(player);

% Perturbation #1: Son constant à haute fréquence (son aigu)
% Perturbation #2: Son constant à base fréquence (son grave)

%% 4.2. 
% Calcul taille des données audio recueillies
L = length(Data);
% Obtenir vecteur représentant la plage de fréquences du fichier audio
f = Fe*(0:(L/2))/L;
% Obtenir fft du signal audio
audio_fft = fft(Data);
% Seulement prendre les valeur positives + normaliser les données
all_data = abs(audio_fft/L);
% Sélectionner seulement la moitié des 
firt_half = all_data(1:L/2+1);
% Doubler amplitude des signaux de la première moitié puisque les signaux
% de la seconde moitié ont été groupé au signaux de la première partie.
firt_half(2:end-1) = 2*firt_half(2:end-1);

plot(f,firt_half) 
title('TDF du signal audio.wav')
xlabel('Fréquence')
ylabel('Intensité (Hz)')

%% 4.3.

% Réponse question: En observant une fréquence de 1244.69 Hz il nous est
% possible d'affirmer que cette fréquence correspond à un ré# ou mib.

%% 4.4. 

% Création du filtre et application de celui-ci sur le fichier audio
lpf = fir1(128, 1240 / Fe, "low");
lpf_data = filter(lpf, 1, Data);

% Affichage du nouveau signal sonore (non demandé)
filtered_data_fft = fft(lpf_data);
all_data = abs(filtered_data_fft/L);
firt_half = all_data(1:L/2+1);
firt_half(2:end-1) = 2*firt_half(2:end-1);

plot(f,firt_half) 
title('TDF du signal audio.wav avec lowpass filter')
xlabel('Fréquence')
ylabel('Intensité (Hz)')

audiowrite('new_audio_with_low_pass.wav', lpf_data, Fe);

% Réponse question: Nous perdons toutes les fréquences supérieure à 1240
% Hz et donc certaines notes de la musique.
% Nous pourrions créer un filtre pour seulement un petit ensemble de
% fréquence ce qui limiterait les pertes.

%% 4.5. 

highPassFilter_Chebyshev = fir1(128,250/Fe,'high',chebwin(128+1, 30));
highPassFilter_Hamming = fir1(128,250/Fe,'high', hamming(128+1));
highPassFilter_Blackman = fir1(128,250/Fe,'high',blackman(128+1));

%% 4.6.

HD1 = dfilt.dffir(highPassFilter_Chebyshev);
HD2 = dfilt.dffir(highPassFilter_Hamming);
HD3 = dfilt.dffir(highPassFilter_Blackman);
[H, w] = freqz([HD1, HD2, HD3]);
figure(2)
subplot(2,1,1);
plot(w/pi,20*log10(abs(H)));
legend('Chebyshev', 'Hamming', 'Blackman');
title('Réponse fréquentielle')
xlabel('Normalized Frequency (x pi rad/sample)')
ylabel('Magnitude (dB)')
grid on
subplot(2,1,2);
plot(w, angle(H));
title('Phase')
xlabel('Normalized Frequency (x pi rad/sample)')
ylabel('Phase (radians)')
grid on

%% 4.7.

[Data,Fe] = audioread('new_audio_with_low_pass.wav');
hpf_Chebyshev = filter(highPassFilter_Chebyshev, 1, Data);
hpf_Hamming = filter(highPassFilter_Hamming, 1, Data);
hpf_Blackman = filter(highPassFilter_Blackman, 1, Data);

audiowrite('Chebyshev.wav', hpf_Chebyshev, Fe);
audiowrite('Hamming.wav', hpf_Chebyshev, Fe);
audiowrite('Blackman.wav', hpf_Chebyshev, Fe);

% Nous remarquons que le son de la fréquence basse s'est vu atténué.
% Nous perdons de l'intensité pour toutes les fréquences inférieures à la 
% fréquence de coupure et donc certaines notes de la musique. Le signal
% restauré sera donc moins fort au niveau des fréquences inférieures à la
% fréquence de coupure, soit 250 Hz.

%% 4.8.
type plotSpectreFrequence.m;

% Les spectres correspondent à ce que nous avons entendu. Effectivement, le
% son très fort en basse fréquence est encore audible, et on voit sur le
% spectre qu'il reste encore plus fort que le reste du signal. Par contre,
% son intensité est plus faible que le signal original.

%% 4.8.1.
clf;
plotSpectreFrequence('Chebyshev.wav');
%% 4.8.2.
clf;
plotSpectreFrequence('Hamming.wav');
%% 4.8.3.
clf;
plotSpectreFrequence('Blackman.wav');




##### SOURCE END #####
--></body></html>